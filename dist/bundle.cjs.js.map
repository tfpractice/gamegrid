{"version":3,"file":"bundle.cjs.js","sources":["../src/node.js","../src/adj.js","../src/join.js","../src/components.js","../src/grid.js"],"sourcesContent":["const { atan, abs, PI } = Math;\n\n// **column** `::  Node ->  Number`\n// returns a node's column property\nexport const column = ({ column }) => column;\n\n// **row** `::  Node ->  Number`\n// returns a node's row property\nexport const row = ({ row }) => row;\n\n// **nodeString** `::  Node ->  String`\n// returns a string representation of a node\nexport const nodeString = ({ column, row }) => `{ node::${column}_${row} }`;\n\n// **node** `::  (Number, Number) -> Node`\n// returns an object with column and row properties\nexport const node = (column = null, row = null) =>\n ({ column, row, toString: () => nodeString({ column, row }) });\n\n // **copy** `::  Node -> Node`\n // returns a copy of a node\nexport const copy = n => node(column(n), row(n));\n\n// **colDiff** `::  Node-> Node -> Number`\n// returns the difference of two nodes column properties\nexport const colDiff = ({ column: c0 }) => ({ column: c1 }) => (c0 - c1);\n\n// **rowDiff** `::  Node-> Node -> Number`\n// returns the difference of two nodes row properties\nexport const rowDiff = ({ row: r0 }) => ({ row: r1 }) => (r0 - r1);\n\n// **tangent** `::  Node-> Node -> Number`\n// returns the column difference to row difference ratio of two nodes\nexport const tangent = n0 => n1 => rowDiff(n0)(n1) / colDiff(n0)(n1);\n\n// **angleBetween** `::  Node -> Node -> Number`\n// returns a the angle between two nodes in radians\nexport const angleBetween = n0 => n1 => ((atan(tangent(n0)(n1)) % PI) + PI) % PI;\n\n// **sameCol** `:: Node -> Node -> Boolean`\n// checks for equality between two nodes column properties\nexport const sameCol = n0 => n1 => abs(colDiff(n0)(n1)) === 0;\n\n// **sameRow** `::  Node -> Node -> Boolean`\n// checks for equality between two nodes row properties\nexport const sameRow = n0 => n1 => abs(rowDiff(n0)(n1)) === 0;\n\n// **samePVector** `::  Node -> Node -> Boolean``\n// checks if two nodes lie on the same positive diagonal\nexport const samePVector = n0 => n1 => angleBetween(n0)(n1) === PI * 0.25;\n\n// **sameNVector** `::  Node -> Node -> Boolean`\n// checks if two nodes lie on the same negative diagonal\nexport const sameNVector = n0 => n1 => angleBetween(n0)(n1) === PI * 0.75;\n\n// **cAdj** `::  Node -> Node -> Boolean`\n// checks if two nodes lie on the same column\nexport const cAdj = n0 => n1 => abs(colDiff(n0)(n1)) < 2;\n\n// **rAdj** `:: Node -> Node -> Boolean\n// checks if two nodes lie on the same row\nexport const rAdj = n0 => n1 => abs(rowDiff(n0)(n1)) < 2;\n\n// **isEquivalent** `::  Node -> Node -> Boolean`\n// checks if two nodes share position\nexport const isEquivalent = c0 => c1 => sameCol(c0)(c1) && sameRow(c0)(c1);\n\n// **xEquivalent** `::  Node -> Node -> Boolean`\n// checks if two nodes don't share position\nexport const xEquivalent = src => alt => !isEquivalent(src)(alt);\n\n// **isNeighbor** `::  Map<edge> ->  node  -> Map<edge>`\n// checks if two different nodes are neighbors\nexport const isNeighbor = n0 => n1 =>\n xEquivalent(n0)(n1) && cAdj(n0)(n1) && rAdj(n0)(n1);\n\n // **cIDs** `::  [Node] -> Set<Number>`\n // returns a Set of a grid's columns\nexport const cIDs = nodes => new Set(nodes.map(column));\n\n // **rIDs** `::  [Node] -> Set<Number>`\n // returns a Set of a grid's rows\nexport const rIDs = nodes => new Set(nodes.map(row));\n","import { Graph, } from 'graph-curry';\nimport { isNeighbor, sameCol, sameNVector, samePVector, sameRow, } from './node';\nconst { nodes, } = Graph;\n\n// **allAdj** `::  Map<edge> ->  node  -> Map<edge>`\n// returns a graph with edges connecting all nodes\nexport const allAdj = g => src => nodes(g).filter(isNeighbor(src));\n\n// **rowAdj** `::  Map<edge> ->  node  -> Map<edge>`\n// returns a graph with edges connecting all rows\nexport const rowAdj = g => src => allAdj(g)(src).filter(sameRow(src));\n\n// **colAdj** `::  Map<edge> ->  node  -> Map<edge>`\n// returns a graph with edges connecting all columns\nexport const colAdj = g => src => allAdj(g)(src).filter(sameCol(src));\n\n// **posAdj** `::  Map<edge> ->  node  -> Map<edge>`\n// returns a graph with edges connecting all positive diagonals\nexport const posAdj = g => src => allAdj(g)(src).filter(samePVector(src));\n\n// **negAdj** `::  Map<edge> ->  node  -> Map<edge>`\n// returns a graph with edges connecting all negative diagonal\nexport const negAdj = g => src => allAdj(g)(src).filter(sameNVector(src));\n","import { Graph, } from 'graph-curry';\nimport { allAdj, colAdj, negAdj, posAdj, rowAdj, } from './adj';\n\nconst { addEdges, nodes, } = Graph;\n\n// **joinAdj** `::  (Map<edge>, node)  -> Map<edge>`\n// returns a copy of a grid with edges joining a nodes and all its neighbors\nexport const joinAdj = (g, src) => addEdges(g)(src, 0)(...allAdj(g)(src));\n\n// **joinCols** `::  (Map<edge>, node)  -> Map<edge>`\n// returns a copy of a grid with edges joining a nodes and all its column neighbors\nexport const joinCols = (g, src) => addEdges(g)(src, 0)(...colAdj(g)(src));\n\n// **joinRows** `::  (Map<edge>, node)  -> Map<edge>`\n// returns a copy of a grid with edges joining a nodes and all its row neighbors\nexport const joinRows = (g, src) => addEdges(g)(src, 0)(...rowAdj(g)(src));\n\n// **joinPVectors** `::  (Map<edge>, node)  -> Map<edge>`\n// returns a copy of a grid with edges joining a nodes and all its positive neighbors\nexport const joinPVectors = (g, src) => addEdges(g)(src, 0)(...posAdj(g)(src));\n\n// **joinNVectors** `::  (Map<edge>, node)  -> Map<edge>`\n// returns a copy of a grid with edges joining a nodes and all its negative neighbors\nexport const joinNVectors = (g, src) => addEdges(g)(src, 0)(...negAdj(g)(src));\n\n// **joinGrid** `::  Map<edge>  -> Map<edge>`\n// returns a copy of a grid with edges joining all nodes with all their neighbors\nexport const joinGrid = grid => nodes(grid).reduce(joinAdj, grid);\n\n// **colGrid** `::  Map<edge> -> Map<edge>`\n// returns a copy of a grid with edges joining all nodes with all their column eighbors\nexport const colGrid = grid => nodes(grid).reduce(joinCols, grid);\n\n// **rowGrid** `::  Map<edge>  -> Map<edge>`\n// returns a copy of a grid with edges joining all nodes with all their row neighbors\nexport const rowGrid = grid => nodes(grid).reduce(joinRows, grid);\n\n// **posGrid** `::  Map<edge>  -> Map<edge>`\n// returns a copy of a grid with edges joining all nodes with all their positive neighbors\nexport const posGrid = grid => nodes(grid).reduce(joinPVectors, grid);\n\n// **negGrid** `::  (Map<edge>, node)  -> Map<edge>`\n// returns a copy of a grid with edges joining all nodes with all their negative neighbors\nexport const negGrid = grid => nodes(grid).reduce(joinNVectors, grid);\n","import { Components, } from 'graph-curry';\nimport { colGrid, negGrid, posGrid, rowGrid, } from './join';\nconst { componentSet, } = Components;\n\n// **colComps** `::  Map<edge>  -> Set<edge>`\n// returns a set of all columnn connected components\nexport const colComps = grid => componentSet(colGrid(grid));\n\n// **rowComps** `::  Map<edge>  -> Set<edge>`\n// returns a set of all row connected components\nexport const rowComps = grid => componentSet(rowGrid(grid));\n\n// **posComps** `::  Map<edge>  -> Set<edge>`\n// returns a set of all positive connected components\nexport const posComps = grid => componentSet(posGrid(grid));\n\n// **negComps** `::  Map<edge>  -> Set<edge>`\n// returns a set of all negative connected components\nexport const negComps = grid => componentSet(negGrid(grid));\n\n// **omniComps** `::  Map<edge>  -> Set<edge>`\n// returns a set of all connected components\nexport const omniComps = grid => [ colComps, negComps, posComps, rowComps, ]\n  .map(f => f(grid)).reduce((set, next) => new Set(set).add(next), new Set);\n  \n// **splitComps** `::  Map<edge>  -> Set<edge>`\n// returns a map of all connected components by direction\nexport const splitComps = g => new Map().set('row', rowComps(g))\n  .set('col', colComps(g)).set('pos', posComps(g)).set('neg', negComps(g));\n","import { Graph, } from 'graph-curry';\nimport { column as getCol, row as getRow, isEquivalent, node, sameCol,\n  sameNVector, samePVector, sameRow, } from './node';\n\nconst { fromElements, nodes, } = Graph;\n\n// **genNodes** `::  (Number, Number) -> [Node]`\n// returns an array of nodes the specified number of columns and rows\nexport const genNodes = (cols = 0, rows = 0) => {\n  const nArr = [];\n  \n  for (let c = cols - 1; c >= 0; c--) {\n    for (let r = rows - 1; r >= 0; r--) {\n      nArr.unshift(node(c, r));\n    }\n  }\n  \n  return nArr;\n};\n\n// **cIDs** `::  Map<edge> -> Set<Number>`\n// returns a Set of a grid's columns\nexport const cIDs = grid => new Set(nodes(grid).map(getCol));\n\n// **rIDs** `::  Map<edge> -> Set<Number>`\n// returns a Set of a grid's rows\nexport const rIDs = grid => new Set(nodes(grid).map(getRow));\n\n// **grid** `::  (Number, Number) -> Map<edge>`\n// returns a Map of edges with the specified number of columns and rows\nexport const grid = (c = 0, r = 0) => fromElements(...genNodes(c, r));\n\n// **copy** `::  Map<edge> ->  node  -> Map<edge>`\n// returns a copy of a grid\nexport const copy = grid => fromElements(...nodes(grid));\n\n// **nodesByColumn** `::  Map<edge> ->  Number  -> [Node]`\n// returns an array of nodes  with the specified column id\nexport const nodesByColumn = grid => (column = 0) =>\n  nodes(grid).filter(sameCol({ column }));\n\n// **nodesByRow** `::  Map<edge> ->  Number  -> [Node]`\n// returns an array of nodes  with the specified row id\nexport const nodesByRow = grid => (row = 0) =>\n  nodes(grid).filter(sameRow({ row }));\n\n// **nodesByPVector** `:: Map<edge> ->  (Number, Number)  -> [Node]`\n// returns an array of nodes on the specified postive diagonal\nexport const nodesByPVector = grid => (column = 0, row = 0) =>\n  nodes(grid).filter(samePVector({ column, row }));\n\n// **nodesByNVector** `:: Map<edge> ->  (Number, Number)  -> [Node]`\n// returns an array of nodes on the specified negative diagonal\nexport const nodesByNVector = grid => (column = 0, row = 0) =>\n  nodes(grid).filter(sameNVector({ column, row }));\n\n// **nodeByPosition** `::  Map<edge> ->  node  -> Node`\n// returns a node at the specified position\nexport const nodeByPosition = grid => (column = 0, row = 0) =>\n  nodes(grid).find(isEquivalent({ column, row }));\n"],"names":["atan","Math","abs","PI","column","row","nodeString","node","toString","copy","n","colDiff","c0","c1","rowDiff","r0","r1","tangent","n0","n1","angleBetween","sameCol","sameRow","samePVector","sameNVector","cAdj","rAdj","isEquivalent","xEquivalent","src","alt","isNeighbor","cIDs","Set","nodes","map","rIDs","Graph","allAdj","g","filter","rowAdj","colAdj","posAdj","negAdj","addEdges","joinAdj","joinCols","joinRows","joinPVectors","joinNVectors","joinGrid","grid","reduce","colGrid","rowGrid","posGrid","negGrid","componentSet","Components","colComps","rowComps","posComps","negComps","omniComps","f","set","next","add","splitComps","Map","fromElements","genNodes","cols","rows","nArr","c","r","unshift","getCol","getRow","nodesByColumn","nodesByRow","nodesByPVector","nodesByNVector","nodeByPosition","find"],"mappings":"0GAAQA,KAAkBC,KAAlBD,KAAME,IAAYD,KAAZC,IAAKC,GAAOF,KAAPE,GAINC,OAAS,iBAAGA,KAAAA,aAAaA,IAIzBC,IAAM,iBAAGA,KAAAA,UAAUA,IAInBC,WAAa,eAAGF,KAAAA,OAAQC,IAAAA,qBAAqBD,MAAUC,QAIvDE,KAAO,cAACH,0DAAS,KAAMC,yDAAM,YACtCD,SAAQC,MAAKG,SAAU,iBAAMF,aAAaF,SAAQC,WAIzCI,KAAO,kBAAKF,MAAKH,OAAOM,GAAIL,IAAIK,KAIhCC,QAAU,eAAWC,KAARR,aAAiB,gBAAWS,KAART,aAAkBQ,GAAKC,IAIxDC,QAAU,eAAQC,KAALV,UAAc,gBAAQW,KAALX,UAAeU,GAAKC,IAIlDC,QAAU,kBAAM,mBAAMH,SAAQI,GAAIC,GAAMR,QAAQO,GAAIC,KAIpDC,aAAe,kBAAM,oBAAQpB,KAAKiB,QAAQC,GAAIC,IAAOhB,GAAMA,IAAMA,KAIjEkB,QAAU,kBAAM,mBAA+B,KAAzBnB,IAAIS,QAAQO,GAAIC,MAItCG,QAAU,kBAAM,mBAA+B,KAAzBpB,IAAIY,QAAQI,GAAIC,MAItCI,YAAc,kBAAM,mBAAMH,cAAaF,GAAIC,KAAa,IAALhB,KAInDqB,YAAc,kBAAM,mBAAMJ,cAAaF,GAAIC,KAAa,IAALhB,KAInDsB,KAAO,kBAAM,mBAAMvB,KAAIS,QAAQO,GAAIC,IAAO,IAI1CO,KAAO,kBAAM,mBAAMxB,KAAIY,QAAQI,GAAIC,IAAO,IAI1CQ,aAAe,kBAAM,mBAAMN,SAAQT,GAAIC,IAAOS,QAAQV,GAAIC,KAI1De,YAAc,kBAAO,oBAAQD,aAAaE,GAAKC,KAI/CC,WAAa,kBAAM,mBAC/BH,aAAYV,GAAIC,IAAOM,KAAKP,GAAIC,IAAOO,KAAKR,GAAIC,KAIpCa,KAAO,kBAAS,IAAIC,KAAIC,EAAMC,IAAI/B,UAIlCgC,KAAO,kBAAS,IAAIH,KAAIC,EAAMC,IAAI9B,yWChFvC6B,MAAWG,iBAAXH,MAIKI,OAAS,kBAAK,mBAAOJ,OAAMK,GAAGC,OAAOT,WAAWF,MAIhDY,OAAS,kBAAK,mBAAOH,QAAOC,GAAGV,GAAKW,OAAOlB,QAAQO,MAInDa,OAAS,kBAAK,mBAAOJ,QAAOC,GAAGV,GAAKW,OAAOnB,QAAQQ,MAInDc,OAAS,kBAAK,mBAAOL,QAAOC,GAAGV,GAAKW,OAAOjB,YAAYM,MAIvDe,OAAS,kBAAK,mBAAON,QAAOC,GAAGV,GAAKW,OAAOhB,YAAYK,0OCnB5DgB,SAAqBR,iBAArBQ,SAAUX,QAAWG,iBAAXH,MAILY,QAAU,SAACP,EAAGV,SAAQgB,UAASN,GAAGV,EAAK,kCAAMS,OAAOC,GAAGV,MAIvDkB,SAAW,SAACR,EAAGV,SAAQgB,UAASN,GAAGV,EAAK,kCAAMa,OAAOH,GAAGV,MAIxDmB,SAAW,SAACT,EAAGV,SAAQgB,UAASN,GAAGV,EAAK,kCAAMY,OAAOF,GAAGV,MAIxDoB,aAAe,SAACV,EAAGV,SAAQgB,UAASN,GAAGV,EAAK,kCAAMc,OAAOJ,GAAGV,MAI5DqB,aAAe,SAACX,EAAGV,SAAQgB,UAASN,GAAGV,EAAK,kCAAMe,OAAOL,GAAGV,MAI5DsB,SAAW,kBAAQjB,SAAMkB,GAAMC,OAAOP,QAASM,IAI/CE,QAAU,kBAAQpB,SAAMkB,GAAMC,OAAON,SAAUK,IAI/CG,QAAU,kBAAQrB,SAAMkB,GAAMC,OAAOL,SAAUI,IAI/CI,QAAU,kBAAQtB,SAAMkB,GAAMC,OAAOJ,aAAcG,IAInDK,QAAU,kBAAQvB,SAAMkB,GAAMC,OAAOH,aAAcE,oNCzCxDM,aAAkBC,sBAAlBD,aAIKE,SAAW,kBAAQF,cAAaJ,QAAQF,KAIxCS,SAAW,kBAAQH,cAAaH,QAAQH,KAIxCU,SAAW,kBAAQJ,cAAaF,QAAQJ,KAIxCW,SAAW,kBAAQL,cAAaD,QAAQL,KAIxCY,UAAY,mBAAUJ,SAAUG,SAAUD,SAAUD,UAC9D1B,IAAI,kBAAK8B,GAAEb,KAAOC,OAAO,SAACa,EAAKC,SAAS,IAAIlC,KAAIiC,GAAKE,IAAID,IAAO,GAAIlC,OAI1DoC,WAAa,mBAAK,GAAIC,MAAMJ,IAAI,MAAOL,SAAStB,IAC1D2B,IAAI,MAAON,SAASrB,IAAI2B,IAAI,MAAOJ,SAASvB,IAAI2B,IAAI,MAAOH,SAASxB,mJCxB/DgC,aAAyBlC,iBAAzBkC,aAAcrC,QAAWG,iBAAXH,MAITsC,SAAW,eAGjB,GAHkBC,0DAAO,EAAGC,yDAAO,EAClCC,KAEGC,EAAIH,EAAO,EAAGG,GAAK,EAAGA,QACxB,GAAIC,GAAIH,EAAO,EAAGG,GAAK,EAAGA,MACxBC,QAAQvE,KAAKqE,EAAGC,UAIlBF,IAKI3C,OAAO,kBAAQ,IAAIC,KAAIC,QAAMkB,GAAMjB,IAAI4C,UAIvC3C,OAAO,kBAAQ,IAAIH,KAAIC,QAAMkB,GAAMjB,IAAI6C,OAIvC5B,KAAO,cAACwB,0DAAI,EAAGC,yDAAI,QAAMN,6CAAgBC,SAASI,EAAGC,MAIrDpE,OAAO,kBAAQ8D,6CAAgBrC,QAAMkB,MAIrC6B,cAAgB,kBAAQ,eAAC7E,0DAAS,QAC7C8B,SAAMkB,GAAMZ,OAAOnB,SAAUjB,cAIlB8E,WAAa,kBAAQ,eAAC7E,0DAAM,QACvC6B,SAAMkB,GAAMZ,OAAOlB,SAAUjB,WAIlB8E,eAAiB,kBAAQ,eAAC/E,0DAAS,EAAGC,yDAAM,QACvD6B,SAAMkB,GAAMZ,OAAOjB,aAAcnB,SAAQC,WAI9B+E,eAAiB,kBAAQ,eAAChF,0DAAS,EAAGC,yDAAM,QACvD6B,SAAMkB,GAAMZ,OAAOhB,aAAcpB,SAAQC,WAI9BgF,eAAiB,kBAAQ,eAACjF,0DAAS,EAAGC,yDAAM,QACvD6B,SAAMkB,GAAMkC,KAAK3D,cAAevB,SAAQC"}