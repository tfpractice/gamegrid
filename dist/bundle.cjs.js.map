{"version":3,"file":"bundle.cjs.js","sources":["../src/node.js","../src/adj.js","../src/join.js","../src/components.js","../src/grid.js"],"sourcesContent":["const { atan, abs, PI } = Math;\n\n// **column** `::  Node ->  Number`\n// returns a node's column property\nexport const column = ({ column }) => column;\n\n// **row** `::  Node ->  Number`\n// returns a node's row property\nexport const row = ({ row }) => row;\n\n// **nodeString** `::  Node ->  String`\n// returns a string representation of a node\nexport const nodeString = ({ column, row }) => `{ node::${column}_${row} }`;\n\n// **node** `::  (Number, Number) -> Node`\n// returns an object with column and row properties\nexport const node = (column = null, row = null) =>\n ({ column, row, toString: () => nodeString({ column, row }) });\n\n // **copy** `::  Node -> Node`\n // returns a copy of a node\nexport const copy = n => node(column(n), row(n));\n\n// **colDiff** `::  Node-> Node -> Number`\n// returns the difference of two nodes column properties\nexport const colDiff = ({ column: c0 }) => ({ column: c1 }) => (c0 - c1);\n\n// **rowDiff** `::  Node-> Node -> Number`\n// returns the difference of two nodes row properties\nexport const rowDiff = ({ row: r0 }) => ({ row: r1 }) => (r0 - r1);\n\n// **tangent** `::  Node-> Node -> Number`\n// returns the column difference to row difference ratio of two nodes\nexport const tangent = n0 => n1 => rowDiff(n0)(n1) / colDiff(n0)(n1);\n\n// **angleBetween** `::  Node -> Node -> Number`\n// returns a the angle between two nodes in radians\nexport const angleBetween = n0 => n1 => ((atan(tangent(n0)(n1)) % PI) + PI) % PI;\n\n// **sameCol** `:: Node -> Node -> Boolean`\n// checks for equality between two nodes column properties\nexport const sameCol = n0 => n1 => abs(colDiff(n0)(n1)) === 0;\n\n// **sameRow** `::  Node -> Node -> Boolean`\n// checks for equality between two nodes row properties\nexport const sameRow = n0 => n1 => abs(rowDiff(n0)(n1)) === 0;\n\n// **samePVector** `::  Node -> Node -> Boolean``\n// checks if two nodes lie on the same positive diagonal\nexport const samePVector = n0 => n1 => angleBetween(n0)(n1) === PI * 0.25;\n\n// **sameNVector** `::  Node -> Node -> Boolean`\n// checks if two nodes lie on the same negative diagonal\nexport const sameNVector = n0 => n1 => angleBetween(n0)(n1) === PI * 0.75;\n\n// **cAdj** `::  Node -> Node -> Boolean`\n// checks if two nodes lie on the same column\nexport const cAdj = n0 => n1 => abs(colDiff(n0)(n1)) < 2;\n\n// **rAdj** `:: Node -> Node -> Boolean\n// checks if two nodes lie on the same row\nexport const rAdj = n0 => n1 => abs(rowDiff(n0)(n1)) < 2;\n\n// **isEquivalent** `::  Node -> Node -> Boolean`\n// checks if two nodes share position\nexport const isEquivalent = c0 => c1 => sameCol(c0)(c1) && sameRow(c0)(c1);\n\n// **xEquivalent** `::  Node -> Node -> Boolean`\n// checks if two nodes don't share position\nexport const xEquivalent = src => alt => !isEquivalent(src)(alt);\n\n// **isNeighbor** `::  Map<edge> ->  node  -> Map<edge>`\n// checks if two different nodes are neighbors\nexport const isNeighbor = n0 => n1 =>\n xEquivalent(n0)(n1) && cAdj(n0)(n1) && rAdj(n0)(n1);\n","import { Graph, } from 'graph-curry';\nimport { isNeighbor, sameCol, sameNVector, samePVector, sameRow, } from './node';\nconst { nodes, } = Graph;\n\n// **allAdj** `::  Map<edge> ->  node  -> Map<edge>`\n// returns a graph with edges connecting all nodes\nexport const allAdj = g => src => nodes(g).filter(isNeighbor(src));\n\n// **rowAdj** `::  Map<edge> ->  node  -> Map<edge>`\n// returns a graph with edges connecting all rows\nexport const rowAdj = g => src => allAdj(g)(src).filter(sameRow(src));\n\n// **colAdj** `::  Map<edge> ->  node  -> Map<edge>`\n// returns a graph with edges connecting all columns\nexport const colAdj = g => src => allAdj(g)(src).filter(sameCol(src));\n\n// **posAdj** `::  Map<edge> ->  node  -> Map<edge>`\n// returns a graph with edges connecting all positive diagonals\nexport const posAdj = g => src => allAdj(g)(src).filter(samePVector(src));\n\n// **negAdj** `::  Map<edge> ->  node  -> Map<edge>`\n// returns a graph with edges connecting all negative diagonal\nexport const negAdj = g => src => allAdj(g)(src).filter(sameNVector(src));\n","import { Graph, } from 'graph-curry';\nimport { allAdj, colAdj, negAdj, posAdj, rowAdj, } from './adj';\n\nconst { addEdges, nodes, } = Graph;\n\n// **joinAdj** `::  (Map<edge>, node)  -> Map<edge>`\n// returns a copy of a grid with edges joining a nodes and all its neighbors\nexport const joinAdj = (g, src) => addEdges(g)(src, 0)(...allAdj(g)(src));\n\n// **joinCols** `::  (Map<edge>, node)  -> Map<edge>`\n// returns a copy of a grid with edges joining a nodes and all its column neighbors\nexport const joinCols = (g, src) => addEdges(g)(src, 0)(...colAdj(g)(src));\n\n// **joinRows** `::  (Map<edge>, node)  -> Map<edge>`\n// returns a copy of a grid with edges joining a nodes and all its row neighbors\nexport const joinRows = (g, src) => addEdges(g)(src, 0)(...rowAdj(g)(src));\n\n// **joinPVectors** `::  (Map<edge>, node)  -> Map<edge>`\n// returns a copy of a grid with edges joining a nodes and all its positive neighbors\nexport const joinPVectors = (g, src) => addEdges(g)(src, 0)(...posAdj(g)(src));\n\n// **joinNVectors** `::  (Map<edge>, node)  -> Map<edge>`\n// returns a copy of a grid with edges joining a nodes and all its negative neighbors\nexport const joinNVectors = (g, src) => addEdges(g)(src, 0)(...negAdj(g)(src));\n\n// **joinGrid** `::  Map<edge>  -> Map<edge>`\n// returns a copy of a grid with edges joining all nodes with all their neighbors\nexport const joinGrid = grid => nodes(grid).reduce(joinAdj, grid);\n\n// **colGrid** `::  Map<edge> -> Map<edge>`\n// returns a copy of a grid with edges joining all nodes with all their column eighbors\nexport const colGrid = grid => nodes(grid).reduce(joinCols, grid);\n\n// **rowGrid** `::  Map<edge>  -> Map<edge>`\n// returns a copy of a grid with edges joining all nodes with all their row neighbors\nexport const rowGrid = grid => nodes(grid).reduce(joinRows, grid);\n\n// **posGrid** `::  Map<edge>  -> Map<edge>`\n// returns a copy of a grid with edges joining all nodes with all their positive neighbors\nexport const posGrid = grid => nodes(grid).reduce(joinPVectors, grid);\n\n// **negGrid** `::  (Map<edge>, node)  -> Map<edge>`\n// returns a copy of a grid with edges joining all nodes with all their negative neighbors\nexport const negGrid = grid => nodes(grid).reduce(joinNVectors, grid);\n","import { Components, } from 'graph-curry';\nimport { colGrid, negGrid, posGrid, rowGrid, } from './join';\nconst { componentSet, } = Components;\n\n// **colComponents** `::  Map<edge>  -> Set<edge>`\n// returns a set of all columnn connected components\nexport const colComponents = grid => componentSet(colGrid(grid));\n\n// **rowComponents** `::  Map<edge>  -> Set<edge>`\n// returns a set of all row connected components\nexport const rowComponents = grid => componentSet(rowGrid(grid));\n\n// **posComponents** `::  Map<edge>  -> Set<edge>`\n// returns a set of all positive connected components\nexport const posComponents = grid => componentSet(posGrid(grid));\n\n// **negComponents** `::  Map<edge>  -> Set<edge>`\n// returns a set of all negative connected components\nexport const negComponents = grid => componentSet(negGrid(grid));\n","import { Graph, } from 'graph-curry';\nimport { column as getCol, row as getRow, isEquivalent, node, sameCol,\n  sameNVector, samePVector, sameRow, } from './node';\n\nconst { fromElements, nodes, } = Graph;\n\n// **genNodes** `::  (Number, Number) -> [Node]`\n// returns an array of nodes the specified number of columns and rows\nexport const genNodes = (cols = 0, rows = 0) => {\n  const nArr = [];\n  \n  for (let c = cols - 1; c >= 0; c--) {\n    for (let r = rows - 1; r >= 0; r--) {\n      nArr.unshift(node(c, r));\n    }\n  }\n  \n  return nArr;\n};\n\n// **cIDs** `::  Map<edge> -> Set<Number>`\n// returns a Set of a grid's columns\nexport const cIDs = grid => new Set(nodes(grid).map(getCol));\n\n// **rIDs** `::  Map<edge> -> Set<Number>`\n// returns a Set of a grid's rows\nexport const rIDs = grid => new Set(nodes(grid).map(getRow));\n\n// **grid** `::  (Number, Number) -> Map<edge>`\n// returns a Map of edges with the specified number of columns and rows\nexport const grid = (c = 0, r = 0) => fromElements(...genNodes(c, r));\n\n// **copy** `::  Map<edge> ->  node  -> Map<edge>`\n// returns a copy of a grid\nexport const copy = grid => fromElements(...nodes(grid));\n\n// **nodesByColumn** `::  Map<edge> ->  Number  -> [Node]`\n// returns an array of nodes  with the specified column id\nexport const nodesByColumn = grid => (column = 0) =>\n  nodes(grid).filter(sameCol({ column }));\n\n// **nodesByRow** `::  Map<edge> ->  Number  -> [Node]`\n// returns an array of nodes  with the specified row id\nexport const nodesByRow = grid => (row = 0) =>\n  nodes(grid).filter(sameRow({ row }));\n\n// **nodesByPVector** `:: Map<edge> ->  (Number, Number)  -> [Node]`\n// returns an array of nodes on the specified postive diagonal\nexport const nodesByPVector = grid => (column = 0, row = 0) =>\n  nodes(grid).filter(samePVector({ column, row }));\n\n// **nodesByNVector** `:: Map<edge> ->  (Number, Number)  -> [Node]`\n// returns an array of nodes on the specified negative diagonal\nexport const nodesByNVector = grid => (column = 0, row = 0) =>\n  nodes(grid).filter(sameNVector({ column, row }));\n\n// **nodeByPosition** `::  Map<edge> ->  node  -> Node`\n// returns a node at the specified position\nexport const nodeByPosition = grid => (column = 0, row = 0) =>\n  nodes(grid).find(isEquivalent({ column, row }));\n"],"names":["atan","Math","abs","PI","column","row","nodeString","node","toString","copy","n","colDiff","c0","c1","rowDiff","r0","r1","tangent","n0","n1","angleBetween","sameCol","sameRow","samePVector","sameNVector","cAdj","rAdj","isEquivalent","xEquivalent","src","alt","isNeighbor","nodes","Graph","allAdj","g","filter","rowAdj","colAdj","posAdj","negAdj","addEdges","joinAdj","joinCols","joinRows","joinPVectors","joinNVectors","joinGrid","grid","reduce","colGrid","rowGrid","posGrid","negGrid","componentSet","Components","colComponents","rowComponents","posComponents","negComponents","fromElements","genNodes","cols","rows","nArr","c","r","unshift","cIDs","Set","map","getCol","rIDs","getRow","nodesByColumn","nodesByRow","nodesByPVector","nodesByNVector","nodeByPosition","find"],"mappings":"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"}