{"version":3,"file":"bundle.es6.js","sources":["../node_modules/fenugreek-collections/dist/bundle.es6.js","../src/node.js","../src/adj.js","../src/join.js","../src/components.js","../src/grid.js"],"sourcesContent":["// **isIterable** `:: obj -> bool`  \n// checks if an object is iterable\nvar isIterable = function isIterable(o) {\n  return !!o[Symbol.iterator];\n};\n\n// **iterify** `:: obj -> iterable`  \n// returns the object or an Iterable<a> containging the object\nvar iterify = function iterify(o) {\n  return isIterable(o) ? o : [o];\n};\n\n// ** isRemovable **`:: obj -> bool`  \n// checks if an object has the delete method\nvar isRemovable = function isRemovable(c) {\n  return !!c.delete;\n};\n\n// ** isHasable **`:: obj -> bool`\n// checks if an object has the 'has' method\nvar isHasable = function isHasable(c) {\n  return !!c.has;\n};\n\n// ** removify **`:: obj -> [map|set] ` \n// returns the object or an Iterable<a> containging the object\nvar removify = function removify(c) {\n  return isRemovable(c) ? c : new Set(iterify(c));\n};\n\n// ** hasify ** `:: obj -> [map|set] ` \n// returns the object or an Iterable<a> containging the object\nvar hasify = function hasify(c) {\n  return isHasable(c) ? c : new Set(iterify(c));\n};\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\n// requires [iterify](iterable.html)\n// **spread** `:: Iterable<a> -> Iterable<a>`  \n// returns an Iterable<a> of the collections default iterator\nvar spread = function spread() {\n  var coll = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return [].concat(toConsumableArray(iterify(coll)));\n};\n\n// **spreadK** `:: Iterable<a> -> Iterable<a>`  \n// returns an Iterable<a> of the collections keys\nvar spreadK = function spreadK() {\n  var coll = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return spread(iterify(coll).keys());\n};\n\n// **spreadV** `:: Iterable<a> -> Iterable<a>`  \n// returns an Iterable<a> of the collections values\nvar spreadV = function spreadV() {\n  var coll = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return spread(iterify(coll).values());\n};\n\n// **spreadE** `:: Iterable<a> -> Iterable<a>`  \n// returns an Iterable<a> of the collections entries\nvar spreadE = function spreadE() {\n  var coll = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return spread(iterify(coll).entries());\n};\n\n// **spreadKV** `:: Iterable<a> -> Iterable<a>`  \n// returns an Iterable<a> of the collections entries\nvar spreadKV = spreadE;\n\n// export default spread;\n\n// requires [spread](spread.html)\n// **map** `:: Iterable<a>  -> (a->b) -> [b]`  \n// returns an Iterable<a> of the return values of a \n// function called on each element of an iterable \nvar map = function map(coll) {\n  return function (fn) {\n    return spread(coll).map(fn);\n  };\n};\n\n// **reduce** `:: Iterable<a>  -> ((a->b), b) -> b`  \n// returns the accumulated value of a function\n// called on each element of an iterable \nvar reduce = function reduce(coll) {\n  return function (fn, init) {\n    return spread(coll).reduce(fn, init);\n  };\n};\n\n// **filter** `:: Iterable<a>  -> (a->bool) -> [a]`  \n// returns the iterable's values which return true for a given function\nvar filter = function filter(coll) {\n  return function (fn) {\n    return spread(coll).filter(fn);\n  };\n};\n\n// **every** `:: Iterable<a>  -> (a->bool) -> bool`  \n// checks if every element of an iterable returns true for a given function\nvar every = function every(coll) {\n  return function (fn) {\n    return spread(coll).every(fn);\n  };\n};\n\n// **some** `:: Iterable<a>  -> (a->b) -> [b]`  \n// checks if any element of an iterable returns true for a given function\nvar some = function some(coll) {\n  return function (fn) {\n    return spread(coll).some(fn);\n  };\n};\n\n// requires [iterify](iterable.html)\n// **tuple** `:: a -> a -> [a]`  \n// returns a [val, key] Iterable<a>\nvar tuple = function tuple(val) {\n  return function (key) {\n    return [key, val];\n  };\n};\n\n// **tupleBin** `:: (a, a) -> [a]`  \n// returns a [val, key] Iterable<a>\nvar tupleBin = function tupleBin(v, k) {\n  return tuple(v)(k);\n};\n\n// **triple** `:: a -> a -> a -> [a]`  \n// returns a [val, key0, key1] Iterable<a>\nvar triple = function triple(val) {\n  return function (key0) {\n    return function (key1) {\n      return [key0, key1, val];\n    };\n  };\n};\n\n// **flatten** `:: Iterable<a> -> Iterable<a> -> [a]`  \n// returns an Iterable<a> of the contents of two iterables\nvar flatten = function flatten(c0) {\n  return function (c1) {\n    return [].concat(toConsumableArray(iterify(c0)), toConsumableArray(iterify(c1)));\n  };\n};\n\n// **flattenBin** `:: (Iterable<a>, Iterable<a>) -> [a]`  \n// returns an Iterable<a> of the contents of two iterables\nvar flattenBin = function flattenBin(c0, c1) {\n  return flatten(c0)(c1);\n};\n\n// **flatTuple** `:: a -> [a] -> [a]`  \n// concatenates an object and an iterable\nvar flatTuple = function flatTuple(c0) {\n  return function (c1) {\n    return [c0].concat(toConsumableArray(iterify(c1)));\n  };\n};\n\n// **flatTupleBin** `:: (Iterable<a>, [a]) -> [a]`  \n// concatenates an object and an iterable\nvar flatTupleBin = function flatTupleBin(c0, c1) {\n  return flatTuple(c0)(c1);\n};\n\n// **append** `:: Iterable<a> -> a -> [a]`  \n// concatenates an iterable and an object\nvar append = function append(coll) {\n  return function (val) {\n    return [].concat(toConsumableArray(iterify(coll)), [val]);\n  };\n};\n\n// **appendBin** `:: (Iterable<a>,a) -> [a]`  \n// concatenates an iterable and an object\nvar appendBin = function appendBin(c, v) {\n  return append(c)(v);\n};\n\n// requires [spread](spread.html), and [iterable](iterable.html)\n// **has** `:: Iterable<a> -> a -> bool`  \n// checks if an iterable contains an element\nvar has = function has(coll) {\n  return function (el) {\n    return hasify(coll).has(el);\n  };\n};\n\n// **xhas** `:: Iterable<a> -> a -> bool`  \n// checks if an iterable does not contain an element\nvar xhas = function xhas(coll) {\n  return function (el) {\n    return !has(coll)(el);\n  };\n};\n\n// **hasK** `:: Iterable<a> -> a -> bool`  \n// checks if an iterables keys contains an element\nvar hasK = function hasK(coll) {\n  return function (k) {\n    return has(spreadK(coll))(k);\n  };\n};\n\n// **xhasK** `:: Iterable<a> -> a -> bool`  \n// checks if an iterables keys does not contain an element\nvar xhasK = function xhasK(coll) {\n  return function (k) {\n    return !hasK(coll)(k);\n  };\n};\n\n// **hasV** `:: Iterable<a> -> a -> bool`  \n// checks if an iterables values contain an element\nvar hasV = function hasV(coll) {\n  return function (v) {\n    return has(spreadV(coll))(v);\n  };\n};\n\n// **xhasV** `:: Iterable<a> -> a -> bool`  \n// checks if an iterables values does not contain an element\nvar xhasV = function xhasV(coll) {\n  return function (v) {\n    return !hasV(coll)(v);\n  };\n};\n\n// **hasKV** `:: Iterable<a> -> [k,v] -> bool`  \n// checks if an iterables keys contain the key of a [k,v] pair\nvar hasKV = function hasKV(coll) {\n  return function (_ref) {\n    var _ref2 = slicedToArray(_ref, 2),\n        k = _ref2[0],\n        v = _ref2[1];\n\n    return hasK(coll)(k);\n  };\n};\n\n// **xhasKV** `:: Iterable<a> -> [k,v] -> bool`  \n// checks if an iterables keys do not contain the key of a [k,v] pair\nvar xhasKV = function xhasKV(coll) {\n  return function (_ref3) {\n    var _ref4 = slicedToArray(_ref3, 2),\n        k = _ref4[0],\n        v = _ref4[1];\n\n    return !hasKV(coll)([k, v]);\n  };\n};\n\n// requires [spread](spread.html)\n// **asArray** `:: Iterable<a> -> [a]`  \n// returns an Iterable<a> of the collections default iterator\nvar asArray = function asArray(c) {\n  return spread(c);\n};\n\n// **asSet** `:: Iterable<a> -> Set[a]`  \n// returns an Iterable<a> of the collections default iterator\nvar asSet = function asSet(c) {\n  return new Set(spread(c));\n};\n\n// **asMap** `:: Iterable<a> -> Map[a]`  \n// returns an Iterable<a> of the collections default iterator\nvar asMap = function asMap(c) {\n  return new Map(spreadKV(c));\n};\n\n// requires [spread](spread.html),[iterable](iterable.html),[cast](cast.html), and [group](group.html)\n// **addBin** `:: [a] -> a -> [a]`  \n// adds an element to a collection;\nvar addBin = function addBin(c, el) {\n  return append(c)(el);\n};\n\n// **addBinSet** `:: a -> a -> Set[a]`  \n// adds an element to a Set;\nvar addBinSet = function addBinSet(c, el) {\n  return new Set(append(c)(el));\n};\n\n// **addBinMap** `:: a -> a -> Map[a]`  \n// adds an element to a Map;\nvar addBinMap = function addBinMap(c, el) {\n  return new Map(append(c)(el));\n};\n\n// **removeBin** `:: Iterable<a> -> a -> Iterable<a>`  \n// removes an element from a collection;\nvar removeBin = function removeBin(c, el) {\n  return removify(c).delete(el) ? c : c;\n};\n\n// **removeBinArray** `:: Iterable<a> -> a -> [a]`  \n// returns a [val, key] arrayimport spread from './spread';\nvar removeBinArray = function removeBinArray(c, el) {\n  return spread(removeBin(asSet(c), el));\n};\n\n// **removeBinTuple** `:: a -> a -> [a]`  \n// returns a [val, key] arrayimport spread from './spread';\nvar removeBinTuple = function removeBinTuple(c, _ref) {\n  var _ref2 = slicedToArray(_ref, 2),\n      k = _ref2[0],\n      v = _ref2[1];\n\n  return removeBin(asMap(c), k);\n};\n\n// requires [has](has.html), [spread](spread.html), and [reducers](reducers.html)\n// **inter** `:: Iterable<a> -> Iterable<a> -> [a]`  \n// returns elements shared between two iterables;\nvar inter = function inter(c0) {\n  return function (c1) {\n    return spread(c0).filter(hasK(c1));\n  };\n};\n\n// **diff** `:: Iterable<a> -> Iterable<a> -> [a]`  \n// returns elements of the first iterable absent from the second iterable\nvar diff = function diff(c0) {\n  return function (c1) {\n    return spread(c0).filter(xhasK(c1));\n  };\n};\n\n// **union** `:: Iterable<a> -> Iterable<a> -> [a]`  \n// returns elements of both iterables\nvar union = function union(c0) {\n  return function (c1) {\n    return spread(c0).concat(diff(c1)(c0));\n  };\n};\n\n// **mapInter** `:: Map[{k:v}] -> Map[{k:v}] -> Map[{k:v}]`  \n// returns elements shared between two maps;\nvar mapInter = function mapInter(c0) {\n  return function (c1) {\n    return spread(c0).filter(hasKV(c1)).reduce(addBinMap, new Map());\n  };\n};\n\n// **mapDiff** `:: Map[{k:v}] -> Map[{k:v}] -> Map[{k:v}]`  \n// returns elements of the first map absent from the second map\nvar mapDiff = function mapDiff(c0) {\n  return function (c1) {\n    return spread(c0).filter(xhasKV(c1)).reduce(addBinMap, new Map());\n  };\n};\n\n// **mapUnion** `:: Map[{k:v}] -> Map[{k:v}] -> Map[{k:v}]`  \n// returns elements of both maps\nvar mapUnion = function mapUnion(c0) {\n  return function (c1) {\n    return spread(mapDiff(c1)(c0)).reduce(addBinMap, new Map(c0));\n  };\n};\n\n// **mapUnion** `:: Map[{k:v}] -> Map[{k:v}] -> Map[{k:v}]`  \n// returns elements of both maps\nvar uniteMap = function uniteMap(c0) {\n  return function (c1) {\n    return spread(mapDiff(c1)(c0)).reduce(addBinMap, c0);\n  };\n};\n\n// requires [spread](spread.html),[reducers](reducers.html), and [cast](cast.html)\n// **addMap** `:: Map[{k:v}] -> k -> v -> Map[{k:v}]`  \n// adds an element to a Map;\nvar addMap = function addMap(c) {\n  return function (k) {\n    return function (v) {\n      return asMap(c).set(k, v);\n    };\n  };\n};\n\n// **addMapTuple** `:: Map[{k:v}] -> (...{k:v}) -> Map[{k:v}]`  \n// adds multiple [k,v] pairs to an iterable;\nvar addMapTuple = function addMapTuple(c) {\n  return function () {\n    for (var _len = arguments.length, tups = Array(_len), _key = 0; _key < _len; _key++) {\n      tups[_key] = arguments[_key];\n    }\n\n    return tups.reduce(addBinMap, c);\n  };\n};\n\n// **addSet** `:: Set[a] -> (...a) -> Set[a]`  \n// adds multiple elements to a Set;\nvar addSet = function addSet(c) {\n  return function () {\n    for (var _len2 = arguments.length, els = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      els[_key2] = arguments[_key2];\n    }\n\n    return els.reduce(addBinSet, c);\n  };\n};\n\n// **removeSet** `:: Set[a] -> (...a) -> Set[a]`  \n// removes multiple elements from a Set;\nvar removeSet = function removeSet(c) {\n  return function () {\n    for (var _len3 = arguments.length, els = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      els[_key3] = arguments[_key3];\n    }\n\n    return els.reduce(removeBin, asSet(c));\n  };\n};\n\n// **removeMap** `:: Map[{k:v}] -> (...k) -> Map[{k:v}]`  \n// removes multiple keys from a Map;\nvar removeMap = function removeMap(c) {\n  return function () {\n    for (var _len4 = arguments.length, els = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      els[_key4] = arguments[_key4];\n    }\n\n    return els.reduce(removeBin, asMap(c));\n  };\n};\n\n// **removeMapTuple** `:: Map[{k:v}] -> (...{k:v}) -> Map[{k:v}]`  \n// removes multiple [k,v] pairs from a Map;\nvar removeMapTuple = function removeMapTuple(c) {\n  return function () {\n    for (var _len5 = arguments.length, tups = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      tups[_key5] = arguments[_key5];\n    }\n\n    return tups.reduce(removeBinTuple, asMap(c));\n  };\n};\n\n// **popElem** `:: Iterable<a> -> a -> Iterable<a>`  \n// removes the last element from an iterable;\nvar popElem = function popElem(c) {\n  return function (el) {\n    return removeBin(c, el) && el;\n  };\n};\n\n// **popFirst** `:: Iterable<a> -> a -> Iterable<a>`  \n// removes the first element from an iterable;\nvar popFirst = function popFirst(c) {\n  return popElem(c)(spread(c).shift());\n};\n\n// requires [cast](cast.html), and [spread](spread.html)\n// **get** `:: Iterable<{k:v}> -> k -> v`  \n// retrieves a value stored at a key from a collection\nvar get$1 = function get(c) {\n  return function (k) {\n    return asMap(c).get(k);\n  };\n};\n\n// **fromIndex** `:: Iterable<a> -> number -> a`  \n// returns the value stored at an Iterable<a> position\nvar fromIndex = function fromIndex() {\n  var c = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Set();\n  return function (i) {\n    return spread(c).slice(i, i + 1).shift();\n  };\n};\n\n// **first** `:: Iterable<a> -> a`  \n// returns the first element of an iterable\nvar first = function first() {\n  var c = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return spread(c).shift();\n};\n\n// **last** `:: Iterable<a> -> a`  \n// returns the last element of an iterable\nvar last = function last() {\n  var c = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return spread(c).pop();\n};\n\n// **firstK** `:: Iterable<{k:v}>  -> k`  \n// returns the first key of an iterable\nvar firstK = function firstK() {\n  var c = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return first(spreadK(c));\n};\n\n// **lastK** `:: Iterable<{k:v}>  -> k`  \n// returns the last key of an iterable\nvar lastK = function lastK() {\n  var c = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return last(spreadK(c));\n};\n\n// **firstV** `:: Iterable<a> -> a`  \n// returns the first value of an iterable\nvar firstV = function firstV() {\n  var c = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return first(spreadV(c));\n};\n\n// **lastV** `:: Iterable<a> -> a -> [a]`  \n// returns the last value of an iterable\nvar lastV = function lastV() {\n  var c = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return last(spreadV(c));\n};\n\n// exports [iterable](iterable.html)\n\nexport { isIterable, iterify, isRemovable, isHasable, removify, hasify, map, reduce, filter, every, some, spread, spreadK, spreadV, spreadE, spreadKV, tuple, tupleBin, triple, flatten, flattenBin, flatTuple, flatTupleBin, append, appendBin, has, xhas, hasK, xhasK, hasV, xhasV, hasKV, xhasKV, addBin, addBinSet, addBinMap, removeBin, removeBinArray, removeBinTuple, inter, diff, union, mapInter, mapDiff, mapUnion, uniteMap, addMap, addMapTuple, addSet, removeSet, removeMap, removeMapTuple, popElem, popFirst, get$1 as get, fromIndex, first, last, firstK, lastK, firstV, lastV, asArray, asSet, asMap };\n//# sourceMappingURL=bundle.es6.js.map\n","import { asSet, spread, } from 'fenugreek-collections';\nconst { atan, abs, PI } = Math;\nconst init = { column: null, row: null, id: '' };\n\n// **column** `::  Node ->  Number`\n// returns a node's column property\nexport const column = ({ column } = init) => column;\n\n// **row** `::  Node ->  Number`\n// returns a node's row property\nexport const row = ({ row } = init) => row;\n\n// **id** `::  Node ->  String`\n// returns a node's row property\nexport const id = ({ id } = init) => id;\n\n// **nodeString** `::  Node ->  String`\n// returns a string representation of a node\nexport const nodeString = ({ column, row } = init) => `{ node::${column}_${row} }`;\n\n// **node** `::  (Number, Number) -> Node`\n// returns an object with column and row properties\nexport const node = (column = null, row = null) =>\n ({ column, row, id: nodeString({ column, row }), });\n\n // **copy** `::  Node -> Node`\n // returns a copy of a node\nexport const copy = n => node(column(n), row(n));\n\n// **colDiff** `::  Node-> Node -> Number`\n// returns the difference of two nodes column properties\nexport const colDiff = ({ column: c0 }) => ({ column: c1 }) => (c0 - c1);\n\n// **rowDiff** `::  Node-> Node -> Number`\n// returns the difference of two nodes row properties\nexport const rowDiff = ({ row: r0 }) => ({ row: r1 }) => (r0 - r1);\n\n// **tangent** `::  Node-> Node -> Number`\n// returns the column difference to row difference ratio of two nodes\nexport const tangent = n0 => n1 => rowDiff(n0)(n1) / colDiff(n0)(n1);\n\n// **angleBetween** `::  Node -> Node -> Number`\n// returns a the angle between two nodes in radians\nexport const angleBetween = n0 => n1 => ((atan(tangent(n0)(n1)) % PI) + PI) % PI;\n\n// **sameCol** `:: Node -> Node -> Boolean`\n// checks for equality between two nodes column properties\nexport const sameCol = n0 => n1 => abs(colDiff(n0)(n1)) === 0;\n\n// **sameRow** `::  Node -> Node -> Boolean`\n// checks for equality between two nodes row properties\nexport const sameRow = n0 => n1 => abs(rowDiff(n0)(n1)) === 0;\n\n// **samePVector** `::  Node -> Node -> Boolean``\n// checks if two nodes lie on the same positive diagonal\nexport const samePVector = n0 => n1 => angleBetween(n0)(n1) === PI * 0.25;\n\n// **sameNVector** `::  Node -> Node -> Boolean`\n// checks if two nodes lie on the same negative diagonal\nexport const sameNVector = n0 => n1 => angleBetween(n0)(n1) === PI * 0.75;\n\n// **cAdj** `::  Node -> Node -> Boolean`\n// checks if two nodes lie on the same column\nexport const cAdj = n0 => n1 => abs(colDiff(n0)(n1)) < 2;\n\n// **rAdj** `:: Node -> Node -> Boolean\n// checks if two nodes lie on the same row\nexport const rAdj = n0 => n1 => abs(rowDiff(n0)(n1)) < 2;\n\n// **isEquivalent** `::  Node -> Node -> Boolean`\n// checks if two nodes share position\nexport const isEquivalent = c0 => c1 => sameCol(c0)(c1) && sameRow(c0)(c1);\n\n// **xEquivalent** `::  Node -> Node -> Boolean`\n// checks if two nodes don't share position\nexport const xEquivalent = src => alt => !isEquivalent(src)(alt);\n\n// **isNeighbor** `::  Map<edge> ->  node  -> Map<edge>`\n// checks if two different nodes are neighbors\nexport const isNeighbor = n0 => n1 =>\n xEquivalent(n0)(n1) && cAdj(n0)(n1) && rAdj(n0)(n1);\n\n // **cIDs** `::  [Node] -> Set<Number>`\n // returns a Set of a grid's columns\nexport const cIDs = nodes => spread(asSet(nodes.map(column)));\n\n // **rIDs** `::  [Node] -> Set<Number>`\n // returns a Set of a grid's rows\nexport const rIDs = nodes => spread(asSet(nodes.map(row)));\n\n// **byColumn** `::  Map<edge> ->  Number  -> [Node]`\n// returns an array of nodes  with the specified column id\nexport const byCol = nodes => (column = 0) => nodes.filter(sameCol({ column }));\n\n// **byRow** `::  Map<edge> ->  Number  -> [Node]`\n// returns an array of nodes  with the specified row id\nexport const byRow = nodes => (row = 0) => nodes.filter(sameRow({ row }));\n\n// **byPVec** `:: Map<edge> ->  (Number, Number)  -> [Node]`\n// returns an array of nodes on the specified postive diagonal\nexport const byPVec = nodes => (column = 0, row = 0) =>\n nodes.filter(samePVector({ column, row }));\n\n// **byNVec** `:: Map<edge> ->  (Number, Number)  -> [Node]`\n// returns an array of nodes on the specified negative diagonal\nexport const byNVec = nodes => (column = 0, row = 0) =>\n  nodes.filter(sameNVector({ column, row }));\n\n// **byPosition** `::  Map<edge> ->  node  -> Node`\n// returns a node at the specified position\nexport const byPosition = nodes => (column = 0, row = 0) =>\n  nodes.find(isEquivalent({ column, row }));\n\n  // **genNodes** `::  (Number, Number) -> [Node]`\n  // returns an array of nodes the specified number of columns and rows\nexport const generate = (cols = 0, rows = 0) => {\n  const nArr = [];\n\n  for (let c = cols - 1; c >= 0; c--) {\n    for (let r = rows - 1; r >= 0; r--) {\n      nArr.unshift(node(c, r));\n    }\n  }\n\n  return nArr;\n};\n","import { Graph, } from 'graph-curry';\nimport { isNeighbor, sameCol, sameNVector, samePVector, sameRow, } from './node';\nconst { nodes, } = Graph;\n\n// **allAdj** `::  Map<edge> ->  node  -> Map<edge>`\n// returns a graph with edges connecting all nodes\nexport const allAdj = g => src => nodes(g).filter(isNeighbor(src));\n\n// **rowAdj** `::  Map<edge> ->  node  -> Map<edge>`\n// returns a graph with edges connecting all rows\nexport const rowAdj = g => src => allAdj(g)(src).filter(sameRow(src));\n\n// **colAdj** `::  Map<edge> ->  node  -> Map<edge>`\n// returns a graph with edges connecting all columns\nexport const colAdj = g => src => allAdj(g)(src).filter(sameCol(src));\n\n// **posAdj** `::  Map<edge> ->  node  -> Map<edge>`\n// returns a graph with edges connecting all positive diagonals\nexport const posAdj = g => src => allAdj(g)(src).filter(samePVector(src));\n\n// **negAdj** `::  Map<edge> ->  node  -> Map<edge>`\n// returns a graph with edges connecting all negative diagonal\nexport const negAdj = g => src => allAdj(g)(src).filter(sameNVector(src));\n","import { Graph, } from 'graph-curry';\nimport { allAdj, colAdj, negAdj, posAdj, rowAdj, } from './adj';\n\nconst { addEdges, nodes, } = Graph;\n\n// **joinAdj** `::  (Map<edge>, node)  -> Map<edge>`\n// returns a copy of a grid with edges joining a nodes and all its neighbors\nexport const joinAdj = (g, src) => addEdges(g)(src, 0)(...allAdj(g)(src));\n\n// **joinCols** `::  (Map<edge>, node)  -> Map<edge>`\n// returns a copy of a grid with edges joining a nodes and all its column neighbors\nexport const joinCols = (g, src) => addEdges(g)(src, 0)(...colAdj(g)(src));\n\n// **joinRows** `::  (Map<edge>, node)  -> Map<edge>`\n// returns a copy of a grid with edges joining a nodes and all its row neighbors\nexport const joinRows = (g, src) => addEdges(g)(src, 0)(...rowAdj(g)(src));\n\n// **joinPVectors** `::  (Map<edge>, node)  -> Map<edge>`\n// returns a copy of a grid with edges joining a nodes and all its positive neighbors\nexport const joinPVectors = (g, src) => addEdges(g)(src, 0)(...posAdj(g)(src));\n\n// **joinNVectors** `::  (Map<edge>, node)  -> Map<edge>`\n// returns a copy of a grid with edges joining a nodes and all its negative neighbors\nexport const joinNVectors = (g, src) => addEdges(g)(src, 0)(...negAdj(g)(src));\n\n// **joinGrid** `::  Map<edge>  -> Map<edge>`\n// returns a copy of a grid with edges joining all nodes with all their neighbors\nexport const joinGrid = grid => nodes(grid).reduce(joinAdj, grid);\n\n// **colGrid** `::  Map<edge> -> Map<edge>`\n// returns a copy of a grid with edges joining all nodes with all their column eighbors\nexport const colGrid = grid => nodes(grid).reduce(joinCols, grid);\n\n// **rowGrid** `::  Map<edge>  -> Map<edge>`\n// returns a copy of a grid with edges joining all nodes with all their row neighbors\nexport const rowGrid = grid => nodes(grid).reduce(joinRows, grid);\n\n// **posGrid** `::  Map<edge>  -> Map<edge>`\n// returns a copy of a grid with edges joining all nodes with all their positive neighbors\nexport const posGrid = grid => nodes(grid).reduce(joinPVectors, grid);\n\n// **negGrid** `::  (Map<edge>, node)  -> Map<edge>`\n// returns a copy of a grid with edges joining all nodes with all their negative neighbors\nexport const negGrid = grid => nodes(grid).reduce(joinNVectors, grid);\n","import { Components, } from 'graph-curry';\nimport { colGrid, negGrid, posGrid, rowGrid, } from './join';\nconst { componentSet, } = Components;\n\n// **colComps** `::  Map<edge>  -> Set<edge>`\n// returns a set of all columnn connected components\nexport const colComps = grid => componentSet(colGrid(grid));\n\n// **rowComps** `::  Map<edge>  -> Set<edge>`\n// returns a set of all row connected components\nexport const rowComps = grid => componentSet(rowGrid(grid));\n\n// **posComps** `::  Map<edge>  -> Set<edge>`\n// returns a set of all positive connected components\nexport const posComps = grid => componentSet(posGrid(grid));\n\n// **negComps** `::  Map<edge>  -> Set<edge>`\n// returns a set of all negative connected components\nexport const negComps = grid => componentSet(negGrid(grid));\n\n// **omniComps** `::  Map<edge>  -> Set<edge>`\n// returns a set of all connected components\nexport const omniComps = grid => [ colComps, negComps, posComps, rowComps, ]\n  .map(f => f(grid)).reduce((set, next) => new Set(set).add(next), new Set);\n  \n// **splitComps** `::  Map<edge>  -> Set<edge>`\n// returns a map of all connected components by direction\nexport const splitComps = g => new Map().set('row', rowComps(g))\n  .set('col', colComps(g)).set('pos', posComps(g)).set('neg', negComps(g));\n","import { Graph, } from 'graph-curry';\nimport { column as getCol, row as getRow, isEquivalent, node, sameCol,\n  sameNVector, samePVector, sameRow, } from './node';\nimport { joinAdj, joinCols, joinPVectors, joinRows, } from './join';\nconst { graph, nodes, } = Graph;\n\n// **genNodes** `::  (Number, Number) -> [Node]`\n// returns an array of nodes the specified number of columns and rows\nexport const genNodes = (cols = 0, rows = 0) => {\n  const nArr = [];\n\n  for (let c = cols - 1; c >= 0; c--) {\n    for (let r = rows - 1; r >= 0; r--) {\n      nArr.unshift(node(c, r));\n    }\n  }\n\n  return nArr;\n};\n\n// **cIDs** `::  Map<edge> -> Set<Number>`\n// returns a Set of a grid's columns\nexport const cIDs = grid => new Set(nodes(grid).map(getCol));\n\n// **rIDs** `::  Map<edge> -> Set<Number>`\n// returns a Set of a grid's rows\nexport const rIDs = grid => new Set(nodes(grid).map(getRow));\n\n// **grid** `::  (Number, Number) -> Map<edge>`\n// returns a Map of edges with the specified number of columns and rows\nexport const grid = (c = 0, r = 0) => graph(...genNodes(c, r));\n\n// **copy** `::  Map<edge> ->  node  -> Map<edge>`\n// returns a copy of a grid\nexport const copy = grid => graph(...nodes(grid));\n\n// **nodesByColumn** `::  Map<edge> ->  Number  -> [Node]`\n// returns an array of nodes  with the specified column id\nexport const nodesByColumn = grid => (column = 0) =>\n  nodes(grid).filter(sameCol({ column }));\n\n// **nodesByRow** `::  Map<edge> ->  Number  -> [Node]`\n// returns an array of nodes  with the specified row id\nexport const nodesByRow = grid => (row = 0) =>\n  nodes(grid).filter(sameRow({ row }));\n\n// **nodesByPVector** `:: Map<edge> ->  (Number, Number)  -> [Node]`\n// returns an array of nodes on the specified postive diagonal\nexport const nodesByPVector = grid => (column = 0, row = 0) =>\n  nodes(grid).filter(samePVector({ column, row }));\n\n// **nodesByNVector** `:: Map<edge> ->  (Number, Number)  -> [Node]`\n// returns an array of nodes on the specified negative diagonal\nexport const nodesByNVector = grid => (column = 0, row = 0) =>\n  nodes(grid).filter(sameNVector({ column, row }));\n\n// **nodeByPosition** `::  Map<edge> ->  node  -> Node`\n// returns a node at the specified position\nexport const nodeByPosition = grid => (column = 0, row = 0) =>\n  nodes(grid).find(isEquivalent({ column, row }));\n\n  // **joinGrid** `::  Map<edge>  -> Map<edge>`\n  // returns a copy of a grid with edges joining all nodes with all their neighbors\nexport const joinGrid = grid => nodes(grid).reduce(joinAdj, grid);\n\n  // **colGrid** `::  Map<edge> -> Map<edge>`\n  // returns a copy of a grid with edges joining all nodes with all their column eighbors\nexport const colGrid = grid => nodes(grid).reduce(joinCols, grid);\n\n  // **rowGrid** `::  Map<edge>  -> Map<edge>`\n  // returns a copy of a grid with edges joining all nodes with all their row neighbors\nexport const rowGrid = grid => nodes(grid).reduce(joinRows, grid);\n\n  // **posGrid** `::  Map<edge>  -> Map<edge>`\n  // returns a copy of a grid with edges joining all nodes with all their positive neighbors\nexport const posGrid = grid => nodes(grid).reduce(joinPVectors, grid);\n\n  // **negGrid** `::  (Map<edge>, node)  -> Map<edge>`\n  // returns a copy of a grid with edges joining all nodes with all their negative neighbors\nexport const negGrid = grid => nodes(grid).reduce(joinNVectors, grid);\n"],"names":["atan","Math","abs","PI","init","column","row","id","nodeString","node","copy","n","colDiff","c0","c1","rowDiff","r0","r1","tangent","n0","n1","angleBetween","sameCol","sameRow","samePVector","sameNVector","cAdj","rAdj","isEquivalent","xEquivalent","src","alt","isNeighbor","cIDs","spread","asSet","nodes","map","rIDs","byCol","filter","byRow","byPVec","byNVec","byPosition","find","generate","cols","rows","nArr","c","r","unshift","Graph","allAdj","g","rowAdj","colAdj","posAdj","negAdj","addEdges","joinAdj","joinCols","joinRows","joinPVectors","joinNVectors","joinGrid","grid","reduce","colGrid","rowGrid","posGrid","negGrid","componentSet","Components","colComps","rowComps","posComps","negComps","omniComps","f","set","next","Set","add","splitComps","Map","graph","genNodes","getCol","getRow","nodesByColumn","nodesByRow","nodesByPVector","nodesByNVector","nodeByPosition"],"mappings":"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"}